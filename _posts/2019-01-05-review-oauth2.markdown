---
layout: post
title:  "OAuth2 정리"
date:   2019-01-05 00:18:23 +0700
categories: [oauth2]
---
기존 프로젝트에서 사용하는 Spring 버전을 4 에서 5로 업데이트를 하면서, Spring Security 관련 코드 수정에서 어려움을 겪었다. 
OAuth2 관련된 코드를 [WebFlux(Reactive Web)](https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html) 에 맞게 변경하는데, 코드의 플로우와 사용하는 용어들이 상당히 낯설었다. 이참에 웹 분야의 인증에 어느 정도 개념을 잡고가야겠다는 생각을 했고, 이제껏 내가 공부한 OAuth2 의 개념에 대해서 첫 번째 포스트로 등록하기로 했다. 
# 배경
### SaaS(Software as a Service) 등장
 - **Twitter, FaceBook, Google** 과 같은 거대 IT 기업들은 자신의 플랫폼에서 제공하는 서비스를 다른 소프트웨어에서도 사용할 수 있는 형태로 제공하는 상호협력 가능한 비즈니스 모델을 만들었다. 이 비즈니스 모델은 업계의 사실상 표준(**De Facto**)이 됬다. 우리가 사용하는 대다수의 모바일 앱들을 보면 구글, 페이스북, 혹은 네이버와 같은 서비스 플랫폼을 통해서 **인증**을 하고, **허가**받은 해당 플랫폼이 제공하는 서비스를 활용한다.
몇몇 예를 들자면, 달리기앱에서 오늘 달린 거리를 페이스북이나 트위터에 바로 올려서 친구들한테 나의 기록을 보여준다. 소개팅 앱에서 페이스북에서 설정한 개인정보(학교, 취미, 관심분야)를 이용해, 적절한 상대를 매칭해주거나 친구목록을 보고 매칭 상대를 제한하기도 한다. 
### 표준화의 필요성 및 OAuth 등장 
 - SaaS 에 등장으로 여러 플랫폼사들은 자신의 서비스 이용을 위한 표준화된 방법이 필요하다는 결정을 하게 된다. 표준 기술체를 만듬으로써, SaaS 를 구현함에 발생하는 기술적인 이슈를 빠르게 해결하고, 플랫폼 서비스를 사용하는 클라이언트가 구현에 발생하는 비용을 줄일 수 있다. 구체적으로 Oauth가 등장한 배경은 [위키](https://ko.wikipedia.org/wiki/OAuth)에 있는 내용을 인용하겠다. 
 >2006년 11월 브래인 쿡은 트위터에 OpenID를 탑재하는 작업을 하고 있었다. 같은 시기, 소셜 북마크 사이트인 Ma.gnolia는, 회원이 OpenID를 사용하여 대시보드 위젯으로 서비스에 접속할 수 있는 인증 방법을 필요로 하고 있었다. 이에 쿡, 크리스 메시나, 래리 하프(Ma.gnolia)는 데이비드 리코던(당시 베리사인)과 만나 OpenID를 활용해 트위터나 Ma.gnolia의 API로 인증을 위임하는 방법을 논의했다. 그 결과, API 접근 위임에 대한 공개 표준이 아직 존재하지 않는다는 결론에 이르렀다.

>OAuth의 인터넷 커뮤니티는 2007년 4월에 탄생하여, 소수 인원으로 새로운 공개 프로토콜의 초안을 썼다. OAuth 프로젝트를 알게 된 구글의 드위트 클린턴은 지원을 표명했다. 2007년 7월, 팀은 사양 초안을 완성시켰다. 에런 해머래해브가 가세하여 많은 협력자들의 조정을 실시하여, 보다 정식적인 사양을 작성해나갔다. 2007년 10월 3일, OAuth 코어 1.0의 최종 초안이 발표되었다.

>2008년 11월, 미네아폴리스에서 열린 제73회의 IETF 회합에서 OAuth의 비공식 회합도 열려 새로운 표준화를 향해 IETF에 OAuth 프로토콜을 제안할지를 논의했다. 회합은 성황을 이루었고 IETF에서 정식으로 OAuth 작업모임을 발족시키는 일에 폭넓은 지지를 얻을 수 있었다.

 Oauth 에 대한 상세한 설명은 [('OAuth와 함께 춤을' - 네이버 D2 포스트)](https://d2.naver.com/helloworld/24942)서 확인하면 된다. 


### OAuth 의 한계 및 OAuth2 의 등장
 - OAuth 의 단점
   - 잦은 

# Oauth2 핵심 용어 정리
- Resource Owner
  - 서비스 제공자에 자원을 소유하고 있는 유저. 보통 End User 를 뜻함.
  - 
- Client
  - 서비스 제공자의 서비스를 활용하는 주체. 보통 어플리케이션을 의미한다. 어플리케이션은 Native Application, Web Application
  - 어플리케이션은 보안 상태에 따라, 두 가지 종류로 구분할 수 있다.
  
- Resource Server
  - 인증, 권한을 제공하는 서비스 제공자이다. FaceBook, Twitter, Google 이 해당 서비스 제공자라고 볼 수 있다. 

 - 그래서 어플리케이션들이 해당 서비스를 이용해서, 사용자들의 정보를 활용하거나 어플리케이션이ㅡ 
 - 사용자가 서비스 
* 보안 이슈
- ID / PW 
* 
- 새로운 형태의 서비스 제공 방식의 출현으로 인해 어플리케이션이 사용자에게 서비스를 제공해주는 방식이 많이 바꼈다.
- SaaS가 어플리케이션 서비스 방식의 대세로 자리매김을 하면서, 서비스 제공자에 자신을 인증하는 방식의 표준이 필요하게 됬다.
- 어플리케이션이 사용자와 서비스 제공자를 연결해주고, 서비스 제공자는 사용자에게 권한을 허락할 것인지 의사를 확인한다 
- 사용자가 허락하면, 서비스 제공자는 어플리케이션에게 서비스 제공자의 서비스에 접근을 할 수 있는 접근 토큰(방문증)을 발급한다.
- 어플리케이션은 그 뒤로 접근 토큰을 사용해서, 서비스 제공자의 서비스를 정해진 권한 범위내에서 사용할 수 있게 된다.  
- SaaS(Software as a Service) 
- 플랫폼화된 서비스의 등장으로 인해, 어플리케이션이 제공하는 서비스는 플랫폼과 연동하게 됨.
- 예를 들면, 달리기 앱을 통해서 성취한 것을 플랫폼에 공유 할 수 있음. 
- 혹은 플랫폼에 등록된 나의 계정 정보를 통해서 서비스를 제공. 
- 
- 기존 인증 방식의 문제점.
  - 기존에는 API Key 방식으로 인증을 했음. 토큰 방식이 없었을 경우, 직접 ID / PW 를 노출해야됨. 안전하지 못함. 토큰을 들고 있게됨. 
- 인증과 권한의 차이.
- JWT 토큰을 사용한 Session 제거.   
## 용어정리 
- Resource Owner 
- Resource Server
- Client
- Authorization Server 

# OAuth2 Grant Type 에 따른 플로우 - Use Case
* Authorization Code
* Client Credential
* Password
* Implicit 
* Password

# OAuth2 와 JWT 토큰
## 토큰 관리 방법

# 토큰 저장 방법 

## 결론

## Reference
 - Wikipedia
 - IETF
 - 

